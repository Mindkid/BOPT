
//
//colocar persistencia no tipo de dados
//

Element* buffer;
Element* workingPointer;
Element* savePointer;



int workingEpoca;
int saveEpoca;


época k -> correspondente à página k

struct bucket  //modificar nome Modifications
{	
	//lista passa (K,V store) char* | int | long 
	//chave que não muda (K;V)		
	int position; //chave
	
	int updatePage;
	Element* newElement;
	bucket* next;		
}

struct pageBucket  //Epocas        
{
	bucket* updatedBucket;
	pageBucket* next; 	
}

bucket[100];
pageBucket[100]; //EpochsModifications

void update(int position, size_t size, void* value)
{
	//cópia alocada na cabeça da working page
	Element* newElement = generateElement(size, value, &workingPointer);
	
	newElement->next = findchild(position + 1);
	
	bucket* newBucket = (bucket*) malloc(sizeof(bucket));
	
	//getPositionBasedOnKey()
	
	newBucket->newElement = newElement;
	newBucket->position = position; // key
	newBucket->updatePage = workingPage; //epoch
	newBucket->next = NULL;
	
	insertBucket(position, newBucket);	
	insertPageBucket(workingPage, newBucket);
	
	if(page(newElement) < page(workingPointer))
		batchingTheFlushs(workingPointer);
}

// findchild aceder à hashtable 
// antes de ir à estrutura

void insertOnPosition(int position, size_t size, void* value)
{
	Element* newElement = generateElement(size, value, &workingPointer);
	newElement->next = findchild(position);
	
	newBucket->newElement = newElement;
	newBucket->position = position;
	newBucket->updatePage = workingPage;
	newBucket->next = NULL;
	
	insertBucket(position, newBucket);	
	insertPageBucket(workingPage, newBucket);
	
	if(page(newElement) < page(workingPointer))
		batchingTheFlushs(workingPointer);
}

void remove(int position)
{
	Element* sonOfRemoved = findChild(position + 1);
	
	bucket* newBucket = (bucket*) malloc(sizeof(bucket));
	newBucket->newElement = sonOfRemoved;
	newBucket->position = position;
	newBucket->updatePage = workingPage;
	newBucket->next = NULL;
	
	insertBucket(position, newBucket);	
	insertPageBucket(workingPage, newBucket);
	
}

// savedPage - workingPages - pendingPages


// modificarNome
void batchingTheFlushs(Element* nextPointer)
{
  	Element* toUpdatePointer = savePointer;
  	  
    while(toUpdatePointer <= nextPointer)
    {
    	FLUSH(toUpdatePointer);
        toUpdatePointer += wordBytes;
    }
    
    savePage ++;
    
    pageBucket* elementsFromHash = getPageBuckets(savePage);
    
    while(elementsFromHash != NULL)
    { 
    	int fatherPosition = elementsFromHash->updatedBucket->position - 1;
    	ELement father = findChild(fatherPostion);
    	
    	saveToLog(father->next, fatherPosition, savePage);
    	
    	father->next = elementsFromHash->updatedBucket->newElement;
    	FLUSH(father->next);
    	removeBucket(elementsFromHash->updatedBucket);
    	removePageBucket(elementsFromHash);
    	elementsFromHash = elementsFromHash->next; 	
    }
    
    savePointer = toUpdatePointer;
    offsets[0] = savePointer - buffer;
    FLUSH(offsets);
}


void recover()
{
	if(savePointer < workingPointer)
	{
		int pageNumber = markedPage();
		recoverLog(pageNumber);
	}

}

void recoverLog(int pageNumber)
{
	Log* entry = getEntries(pageNumber);
	while(entry != NULL)
	{
		Element* father = findChild(entry->fatherPosition);
		father->next = entry->fatherNext;
		FLUSH(father->next);
		entry = entry->next;	
	}
}

